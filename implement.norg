@code ruby
  
  # model einteilung_rotations
  # scope :by_tag , -> (tag) { 
  # includes(:team, :kontingent, 
  # :kontingent => [:team]).where("von <= ? and bis >= ?", tag, tag) }
  def rotation_am(date = Date.today)
    einteilung_rotations.by_tag(date).order(:prioritaet)
  end

  def get_default_team(default_team = nil, default_kontingent = nil)
    team = nil
    if default_team.nil?
      default_team = Team.find_by(default: true)
    end
    if default_team.nil? && default_kontingent.nil?
      default_kontingent = Kontingent.includes(:team).find_by(default: true)
    end

    if default_team.present?
      team = default_team
    elsif default_kontingent.present?
      team = default_kontingent.team
    end  
    team
  end

  # Rotationen sollten nach Priorität sortiert übergeben werden!!!
  def team_am(date = Date.today, rotationen = nil, 
    default_team = nil, default_kontingent = nil)
    team = nil
    # Falls keine Rotation übergeben wird, werden alle Rotationen der Mitarbeiterin an diesem Tag geholt
    # Mit der übergabe von rotation = false, lässt sich dieser Schritt überspringen,
    # damit keine weitere Abfrage an die Datenbank gemacht wird
    rotation = nil
    if rotationen.present?
      rotation = rotationen.find { |r| r.von <= date && r.bis >= date }
    elsif rotationen.nil?
      rot = rotation_am(date)
      if rot.present?
        rotation = rot.first
      end
    end

    # Falls keine Rotation existiert, wird das Team aus der Funktion geholt
    if rotation.present? && rotation.team.present?
      team = rotation.team
    elsif funktion_team.present?
      team = funktion_team
    end 

    # Falls kein Team existiert, wird das Default-Team geholt
    if team.nil?
      team = get_default_team(default_team, default_kontingent)    
    end

    team
  end

  def details
    # Einteilungen in die Kontingente
    hash = Hash.new    
    user = current_user
    is_rotationsplaner = user.has_role?("Rotationsplaner Anästhesie HD")
    @mitarbeiter = is_rotationsplaner 
    ? Mitarbeiter.includes(
      :funktion, :accountInfo, 
      :kontingente_default_eingeteilts_sum, 
      :sorted_by_von_einteilung_rotations, 
      :sorted_by_von_einteilung_rotations => [
      :kontingent
      ]).find(params[:id]) 
    : Mitarbeiter.includes(
      :funktion, :accountInfo, 
      :kontingente_default_eingeteilts_sum, 
      :published_einteilung_rotations, 
      :published_einteilung_rotations => [
      :kontingent
    ]).find(params[:id])

    hash['mitarbeiter'] = @mitarbeiter
      .as_json(:include => [:funktion], 
        :methods => [:weiterbildungsjahr]
      )

    hash['team_am'] = @mitarbeiter.team_am(Date.today)

    teams = Team.all
    hash['teams'] = ApplicationRecord.hash_by_key(teams)

    hash['accountInfo'] = @mitarbeiter
      .accountInfo.as_json(:methods => [:file_preview, :renten_eintritt])

    freigaben = ApplicationRecord
      .execute_sql(
        'SELECT freigabetyps.id as id, freigabetyps.name as name, 
        freigabes.freigabestatus_id 
        FROM freigabetyps 
        LEFT OUTER JOIN (
          SELECT * FROM dienstfreigabes 
          WHERE mitarbeiter_id = '+params[:id]+' 
        ) as freigabes 
        ON freigabetyps.id = freigabes.freigabetyp_id 
        ORDER BY sort, name ASC'
      )
    hash['freigaben'] = freigaben.as_json

    freigabestatus = Freigabestatus.all.order(:name).index_by(&:id)
    hash['statuse'] = freigabestatus

    dienste = Mitarbeiter
      .includes(:aktive_freigaben).find(@mitarbeiter.id).freigegebeneDienste()
    hash['dienste'] = dienste.as_json(:only => [:id, :name])

    ratings = Mitarbeiter.find(params[:id]).dienstratings.index_by(&:po_dienst_id) 
    hash['ratings'] = ratings.as_json

    dienstwunsche = Dienstwunsch
      .where("mitarbeiter_id = %d and tag >= '%s'" 
        % [@mitarbeiter.id,Date.today.at_beginning_of_month])
    hash['dienstwunsche'] = dienstwunsche.as_json

    dienstkategories = Dienstkategorie
      .includes(
        :themas, :teams, 
        :dienstkategoriethemas, :dienstkategorie_teams
      ).all

    hash['dienstkategories'] = dienstkategories
      .as_json(:only => [
        :id , :name, :beschreibung, :color, 
        :selectable, :poppix_name, :order, :mark
        ], 
        :include => [
          :dienstkategoriethemas, :dienstkategorie_teams
        ], :methods => [:themaDetails, :teamDetails])

    vertragsphase = VertragsPhase.includes(:vertrag)
      .where(vertrags: {mitarbeiter_id: @mitarbeiter.id})
      .order(von: :desc, bis: :desc)
    hash['vertragsphase'] = vertragsphase

    hash['automatische_einteilungen'] = AutomatischeEinteilungen
      .includes(:mitarbeiter, :zeitraumkategorie, :po_dienst)
      .where(mitarbeiter_id: @mitarbeiter.id)
      .as_json(:methods => [:anfang, :ende], 
        :include => [:po_dienst, :zeitraumkategorie]
      )

    hash['arbeitszeit_absprachen'] = ArbeitszeitAbsprachen
      .includes(:mitarbeiter, :zeitraumkategorie)
      .where(mitarbeiter_id: @mitarbeiter.id)
      .as_json(:methods => 
        [:anfang, :ende, :arbeitszeit_von_time, :arbeitszeit_bis_time], 
        :include => [:zeitraumkategorie]
      )

    hash['nicht_einteilen_absprachen'] = NichtEinteilenAbsprachen
      .includes(:mitarbeiter, :zeitraumkategorie, 
        :nicht_einteilen_standort_themens, 
        :nicht_einteilen_standort_themens => [:standort, :thema]
      )
      .where(mitarbeiter_id: @mitarbeiter.id)
      .as_json(:methods => [:anfang, :ende], 
        :include => [
          :zeitraumkategorie, :nicht_einteilen_standort_themens, 
          :nicht_einteilen_standort_themens => {
            :include => [:standort, :thema]
          }
        ])

    hash['urlaubssaldo_absprachen'] = UrlaubssaldoAbsprache
      .includes(:mitarbeiter).where(mitarbeiter_id: @mitarbeiter.id)

    hash['dienstfrei'] = get_dienstfrei([@mitarbeiter.id])

    overview = Geraetepass
      .search_overview(@mitarbeiter, {mitarbeiter_id: @mitarbeiter.id})
    hash['geraetepaesse'] = overview[:geraete]

    anfang = Date.today.at_beginning_of_month
    ende = (anfang + 8.months).at_end_of_month
    dienstwunsch_verteilung = Dienstwunsch.verteilung(anfang, ende, true)
    hash['dienstwunsch_verteilung'] = dienstwunsch_verteilung.as_json

    dateien = Mitarbeiter.find(params[:id])
      .dateis
      .order(created_at: :desc)
      .as_json(:only => [:id, :created_at] , 
        :methods => :file_url, 
        :include =>{ :datei_typ => {:only => :name}}
      )
    hash['dateien'] = dateien

    merkmale = Merkmal.includes(:merkmal_options).all
    hash['merkmale'] = merkmale.as_json(:include => [:merkmal_options])

    m_merkmale = Mitarbeitermerkmal.all
    hash['mitarbeiter_merkmale'] = m_merkmale
    overview = Geraetepass
      .search_overview(@mitarbeiter, {mitarbeiter_id: @mitarbeiter.id})
    hash['geraetepaesse'] = overview[:geraete]


    # can be removed if everything is working as before
    # hash['einteilungen'] = get_einteilungen.as_json(:include =>[:po_dienst, :einteilungsstatus])

    statistic = @mitarbeiter.get_kontingent_eingeteilt_basis(Kontingent.all)
    einteilungen = Mitarbeiter
      .get_einteilungen_in_kontingente([@mitarbeiter.id], is_rotationsplaner)
    einteilungen.each do |e|
      @mitarbeiter.count_einteilung_in_kontingent(e, statistic)
    end
    hash[:kontingente] = statistic[:kontingente]
    hash[:rotationen] = statistic[:rotationen]
    hash['alle_rotationen'] = is_rotationsplaner 
    ? @mitarbeiter.sorted_by_von_einteilung_rotations 
    : @mitarbeiter.published_einteilung_rotations

    if hash['alle_rotationen'].present?
      hash['alle_rotationen'].each do |rot|
        hash[:rotationen][rot.kontingent_id].push(rot)
      end
    end
    if @mitarbeiter.accountInfo.present? && @mitarbeiter.accountInfo.user.present?
      hash[:rollen] = @mitarbeiter.accountInfo.user.roles
    else
      hash[:rollen] = []
    end

    respond_with(hash.to_json)
  end

  def get_dienstfrei(mitarbeiter_ids = [])
    eingeteilt = {}
    today = Date.today
    dates = ((today.last_month.at_beginning_of_month)..(today.next_month.at_end_of_month))
    @dienstfrei = Diensteinteilung.possible_dienstfrei(dates, mitarbeiter_ids)
    result = []
    @dienstfrei.find_in_batches do |batch|
      batch.each do |df|
        dates.each do |date|
          break if (date - df.tag).to_i > 14
          if df.should_add_dienstfrei(date, nil, eingeteilt)
            result.push({
              tag: date,
              description: "Status: #{df.einteilungsstatus.name}\nDienstfrei aus #{df.po_dienst.name} am #{df.tag}.",
              label: "Dienstfrei",
              id: "#{df.id}_#{date}",
              color: "#d3d3d3"
            })
          end
        end
      end
    end
    result
  end
@end
